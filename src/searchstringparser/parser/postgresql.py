# -*- coding: utf-8 -*-


from __future__ import (absolute_import, unicode_literals)


"""
==============================
PostgreSQL Search Token Parser
==============================

:Authors:
    Moritz Emanuel Beber
:Date:
    2015-09-16
:Copyright:
    Copyright |c| 2015, Max-Plank-Institute for Molecular Genetics, all rights reserved.
:File:
    postgresql.py

.. |c| unicode: U+A9

This parser implements the following rules using the tokens generated by an
appropriate lexer. The goal is to generate a string for PostgreSQL full text
search that conforms with the syntax understood by the function [ts_query]().


term : term term
       | term LITERAL_QUOTE
       | term SYMBOL
       | LITERAL_QUOTE
       | SYMBOL

expression : expression expression
           | expression AND expression
           | expression OR expression
           | NOT expression
           | LPAREN expression RPAREN
           | QUOTE term QUOTE
           | WORD WILDCARD
           | WORD

"""


__all__ = ["PostgreSQLTextSearchParser"]


import ply.yacc as yacc

from ..lexer import GeneralSearchStringLexer


class PostgreSQLTextSearchParser(object):

    precedence = (
        ("left", "OR"),
        ("left", "AND"),
        ("right", "NOT"),
        ("left", "WILDCARD")
    )

    def __init__(self, lexer=None, **kw_args):
        super(PostgreSQLTextSearchParser, self).__init__()
        self.lexer = GeneralSearchStringLexer() if lexer is None else lexer
        self.tokens = self.lexer.tokens
        self.parser = yacc.yacc(module=self, **kw_args)

    def parse(self, data, debug=False, tracking=False, tokenfunc=None):
        self.lexer._invalid = list()
        self.lexer._invalid_pos = list()
        return self.parser.parse(data, lexer=self.lexer, debug=debug,
                tracking=tracking, tokenfunc=tokenfunc)

    def get_illegal(self):
        self.lexer.get_illegal()

    def p_error(self, p):
        if p is None:
            raise SyntaxError("Syntax error at EOF!")
        raise SyntaxError(str(p))

    def p_expression_space(self, p):
        """expression : expression expression %prec AND"""
        p[0] = "{} & {}".format(p[1], p[2])

    def p_expression_and(self, p):
        """expression : expression AND expression"""
        p[0] = "{} & {}".format(p[1], p[3])

    def p_expression_or(self, p):
        """expression : expression OR expression"""
        p[0] = "{} | {}".format(p[1], p[3])

    def p_expression_unot(self, p):
        """expression : NOT expression"""
        p[0] = "!{}".format(p[2])

    def p_expression_parens(self, p):
        """expression : LPAREN expression RPAREN"""
        p[0] = "({})".format(p[2])

    def p_expression_quoted(self, p):
        """expression : QUOTE term QUOTE"""
        p[0] = "'{}'".format(p[2])

    def p_expression_word_wildcard(self, p):
        """expression : WORD WILDCARD"""
        p[0] = "{}:*".format(p[1])

    def p_expression_word(self, p):
        """expression : WORD"""
        p[0] = p[1]

    def p_term_term_space_term(self, p):
        """term : term term %prec AND"""
        p[0] = "{} {}".format(p[1], p[2])

    def p_term_term_and_literal_quote(self, p):
        """term : term LITERAL_QUOTE %prec WILDCARD"""
        p[0] = "{}''".format(p[1])

    def p_term_term_and_symbol(self, p):
        """term : term SYMBOL %prec WILDCARD"""
        p[0] = "{}{}".format(p[1], p[2])

    def p_term_literal_quote(self, p):
        """term : LITERAL_QUOTE"""
        p[0] = "''"

    def p_term_symbol(self, p):
        """term : SYMBOL"""
        p[0] = p[1]

